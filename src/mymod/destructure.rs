pub mod cortaje {
    pub fn main() {
        let pair = (-1, 0);
        // ЗАДАНИЕ ^ Попробуйте другие значения для `pair`

        println!("Tell me about {:?}", pair);
        // Match можно использовать для деструктуризации кортежей
        match pair {
            // Деструктурируем два значения
            (0, y) => println!("Первое значение `0`, а `y` равно `{:?}`", y),
            (x, 0) => println!("`x` равно `{:?}`, а второе значение `0`", x),
            _ => println!("Неважно, какого они значения"),
            // `_` означает, что значение не будет связано с переменной
        }
    }
}

pub mod enums {
    // `allow` необходим, чтобы компилятор не выводил предупреждения,
// т.к используется только один вариант
    #[allow(dead_code)]
    enum Color {
        // Эти 3 перечисления определяют цвет по названию.
        Red,
        Blue,
        Green,
        // Остальные используют `u32` кортежи для идентификации цветовых моделей.
        RGB(u32, u32, u32),
        HSV(u32, u32, u32),
        HSL(u32, u32, u32),
        CMY(u32, u32, u32),
        CMYK(u32, u32, u32, u32),
    }

    pub fn main() {
        let color = Color::RGB(122, 17, 40);
        // ЗАДАНИЕ ^ Попробуйте другие значения для `color`

        println!("Какой это цвет?");
        // `enum` может быть деструктурирован с помощью `match`.
        match color {
            Color::Red => println!("Красный цвет!"),
            Color::Blue => println!("Синий цвет!"),
            Color::Green => println!("Зелёный цвет!"),
            Color::RGB(r, g, b) =>
                println!("Красный: {}, зелёный: {}, и синий: {}!", r, g, b),
            Color::HSV(h, s, v) =>
                println!("Тон: {}, насыщенность: {}, значение: {}!", h, s, v),
            Color::HSL(h, s, l) =>
                println!("Тон: {}, насыщенность: {}, светлота: {}!", h, s, l),
            Color::CMY(c, m, y) =>
                println!("Голубой: {}, пурпурный: {}, жёлтый: {}!", c, m, y),
            Color::CMYK(c, m, y, k) =>
                println!("Голубой: {}, пурпурный: {}, жёлтый: {}, key (чёрный): {}!",
                         c, m, y, k),
            // Нет необходимости в других ветвях, т.к были рассмотрены все варианты
        }
    }
}

pub mod links {
    pub fn main() {
        // Присваиваем ссылку на тип `i32`.
        // Символ `&` означает, что присваивается ссылка.
        let reference = &4;

        match reference {
            // Если `reference` - это шаблон, который сопоставляется с `&val`,
            // то это приведёт к сравнению:
            // `&i32`
            // `&val`
            // ^ Мы видим, что если отбросить сопоставляемые `&`,
            // то переменной `val` должно быть присвоено `i32`.
            &val => println!("Получаем значение через деструктуризацию: {:?}", val),
        }

        // Чтобы избежать символа `&`, нужно разыменовывать ссылку до сопоставления.
        match *reference {
            val => println!("Получаем значение через разыменование: {:?}", val),
        }

        // Что если у нас нет ссылки? `reference` была с `&`,
        // потому что правая часть была ссылкой. Но это не ссылка,
        // потому что правая часть ею не является.
        let _not_a_reference = 3;

        // Rust предоставляет ключевое слово `ref` именно для этой цели.
        // Оно изменяет присваивание так, что создаётся ссылка для элемента.
        // Теперь ссылка присвоена.
        let ref _is_a_reference = 3;

        // Соответственно, для определения двух значений без ссылок,
        // ссылки можно назначить с помощью `ref` и `ref mut`.
        let value = 5;
        let mut mut_value = 6;

        // Используйте ключевое слово `ref` для создания ссылки.
        match value {
            ref r => println!("Получили ссылку на значение: {:?}", r),
        }

        // Используйте `ref mut` аналогичным образом.
        match mut_value {
            ref mut m => {
                // Получаем ссылку. Её нужно разыменовать,
                // прежде чем мы сможем что-то добавить.
                *m += 10;
                println!("Мы добавили 10. `mut_value`: {:?}", m);
            }
        }
    }
}

pub mod structures {
    pub fn main() {
        struct Foo { x: (u32, u32), y: u32 }

        // деструктуризация члена структуры
        let foo = Foo { x: (1, 2), y: 3 };
        let Foo { x: (a, b), y } = foo;

        println!("a = {}, b = {},  y = {} ", a, b, y);

        // Вы можете деструктурировать структуру и переименовывать переменные,
        // порядок при этом не важен

        let Foo { y: i, x: j } = foo;
        println!("i = {:?}, j = {:?}", i, j);

        // а так же можно проигнорировать часть переменных:
        let Foo { y, .. } = foo;
        println!("y = {}", y);

        // следующий код выдаст ошибку: в шаблоне нет упоминания поля `x`
        // let Foo { y } = foo;
    }
}